import {
  BadRequestException,
  ConflictException,
  ForbiddenException,
  Injectable,
  InternalServerErrorException,
  Logger,
  LoggerService,
  NotFoundException,
} from '@nestjs/common'
import { CreateAccessDto } from './dto/create-access.dto'
import { UpdateAccessDto } from './dto/update-access.dto'
import { IActiveUser } from 'src/iam/interfaces/i-active-user'
import { FilterQuery, Model } from 'mongoose'
import { InjectModel } from '@nestjs/mongoose'
import { RolesService } from '../roles/roles.service'
import { UsersService } from 'src/iam/users/users.service'
import { FactoryUtils } from 'src/common/services/factory-utils'
import { Access } from './schema/access.schema'
import { EPremiumRoles, ERoles } from 'src/iam/enums/e-roles.enum'
import { CreateUserDto } from 'src/iam/users/dto/create-user.dto'
import { ERoleTypes } from '../roles/enums/e-role-types'

@Injectable()
export class AccessesService {
  private readonly logger: LoggerService = new Logger(AccessesService.name)
  private readonly MAX_GUEST_TEAM = 3
  private readonly MAX_PREMIUM_TEAM = 12

  constructor(
    @InjectModel(Access.name)
    private readonly accessesModel: Model<Access>,

    private readonly rolesService: RolesService,

    private readonly usersService: UsersService,

    private readonly factoryUtils: FactoryUtils,
  ) {}

  async create(createAccessDto: CreateAccessDto, activeUser: IActiveUser) {
    //ensures user can create acess before proceeding
    try {
      const errorMessage =
        'Failed to asign role since you lack the proper creadentials'
      const roleToAssign = CreateAccessDto.roleId.toString()

      await this.validateRequestAction(activeUser, errorMessage, roleToAssign)

      //Can create new access
      createAccessDto['accountOwner'] = activeUser.sub
      createAccessDto['baseRole'] = activeUser.baseRole

      const createdAccess = await this.accessesModel.create(CreateUserDto)
      return createdAccess
    } catch (error) {
      //logger
      this.logger.warn(error.message)
      this.logger.error(error)

      //validation message
      if (error instanceof NotFoundException) {
        new NotFoundException(error.message)
      }

      if (error instanceof ForbiddenException) {
        new ForbiddenException(error.message)
      }

      if (error.code === 11000) {
        const message = this.factoryUtils.autoGenerateDuplicateMessage(error)
        throw new ConflictException(message || error.message)
      }

      if (error instanceof error && error.name === 'validationError') {
        throw new BadRequestException(error.name)
      }

      throw new InternalServerErrorException(
        'Server failed to create new access. Please try again later',
      )
    }
    // who is the current user accessing the account & who is the manager
  }

  async findAll(activeUser: IActiveUser, filters?: FilterQuery<Access>) {
    //@Todo: implement pagination
    return this.accessesModel.find({
      ...filters,
      accountOwner: activeUser.sub,
    })
  }

  async findOne(
    accessId: string,
    activeUser: IActiveUser,
    isEnabled?: boolean,
  ) {
    const foundRole = await this.accessesModel.findOne({
      _id: accessId,
      accoutOwner: activeUser.sub,
      ...(isEnabled ? { isEnable: true } : {}),
    })
    if (!foundRole) {
      throw new NotFoundException('Access not found')
    }
    return foundRole
  }

  async update(
    accessId: string,
    updateAccessDto: UpdateAccessDto,
    activeUser: IActiveUser,
  ) {
    //first find the access the user wants to update
    const foundAccess = await this.findOne(accessId, activeUser)
    const roleId = foundAccess.roleId.toString()

    //validate update
    if (updateAccessDto?.roleId) {
      const errorMessage = 'Not enough credentials'

      await this.validateRequestAction(activeUser, roleId, errorMessage)
    }
    const updatedAccess = await foundAccess.updateOne(
      {
        _id: accessId,
        accountOwner: activeUser.sub,
      },
      updateAccessDto,
    )

    return updatedAccess
  }

  async remove(accessId: string, activeUser: IActiveUser) {
    //first find the access the user want to delete
    const foundAccessToDelete = await this.findOne(accessId, activeUser)
    const roleId = foundAccessToDelete.roleId.toString()

    //ensure user can delete validation
    const errorMessage = 'not enough credentials'

    await this.validateRequestAction(activeUser, roleId, errorMessage)

    //delte the access

    await foundAccessToDelete.deleteOne({
      _id: accessId,
      accountOwner: activeUser.sub,
    })
    return {
      message: 'Access has been succesfully deleted',
    }
  }
  /**
   * --------------------------------------------------------
   * -----------------helpers
   * ----------------------------------------------------------------
   */

  /**
   * Ensures that a user trying to create a role has the right to create it
   * @param activeUser
   * @param createAccessDto
   */
  private async validateRequestAction(
    activeUser: IActiveUser,
    roleId: string,
    errorMessage: string,
  ) {
    const { sub: accountOwner, baseRole, role } = activeUser

    const whoIs = this.factoryUtils.whoIs(activeUser)
    const managerId = whoIs === accountOwner ? undefined : whoIs

    //find type of the current user belongs
    const type =
      role === ERoles.ADMIN || baseRole === EPremiumRoles.ADMIN
        ? ERoleTypes.ADMIN
        : ERoleTypes.REGULAR

    //fetch the role user want to assign
    const roleData = await this.rolesService.findOne(roleId, activeUser, type, {
      isEnabled: true,
    })

    const roleName = roleData.name

    //validations
    if (managerId) {
      //handling premium, guest and teams manager

      if (baseRole !== EPremiumRoles.ADMIN && roleName !== ERoles.MEMBER) {
        throw new ForbiddenException(errorMessage)
      }

      //handles admin manager
      if (
        baseRole === EPremiumRoles.ADMIN &&
        (roleName === ERoles.ADMIN ||
          roleName === ERoles.MANAGER ||
          roleName === ERoles.MEMBER ||
          roleName === ERoles.ADMIN_MANAGER)
      ) {
        throw new ForbiddenException(errorMessage)
      }
    }

    //handles account owner

    if (role !== ERoles.ADMIN) {
      if (roleName !== ERoles.MANAGER && roleName !== ERoles.MEMBER) {
        throw new ForbiddenException(errorMessage)
      }
    }
  }
}
