import {
  BadRequestException,
  ConflictException,
  ForbiddenException,
  Inject,
  Injectable,
  InternalServerErrorException,
  Logger,
  LoggerService,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common'
import { SignUpDto } from './dto/sign-up.dto'
import { SignInDto } from './dto/sign-in.dto'
import { ConfigType } from '@nestjs/config'
import { jwtConfigs } from '../configs/jwt.configs'
import { UsersService } from 'src/iam/users/users.service'
import { JwtService } from '@nestjs/jwt'
import { TUserDoc } from 'src/iam/users/schema/user.schema'
import { FactoryUtils } from 'src/common/services/factory-utils'
import { RolesService } from 'src/iam/authorization/roles/roles.service'
import { AccessesService } from 'src/iam/authorization/accesses/accesses.service'
import { HashingService } from '../bcrypt/hashing.service'
import { EPremiumSubscribers } from 'src/iam/enums/e-roles.enum'
import { IActiveUser } from 'src/iam/interfaces/i-active-user'

@Injectable()
export class AuthService {
  private readonly logger: LoggerService = new Logger(AuthService.name)

  private readonly defaultRole: EPremiumSubscribers =
    EPremiumSubscribers.GUEST_USER

  constructor(
    @Inject(jwtConfigs.KEY)
    private readonly jwtConfig: ConfigType<typeof jwtConfigs>,

    private readonly usersService: UsersService,

    private readonly accessesService: AccessesService,

    private readonly hashingService: HashingService,

    private readonly rolesService: RolesService,

    private readonly factoryUtils: FactoryUtils,

    private readonly jwtService: JwtService,
  ) {}
  async signUp(signUpDto: SignUpDto) {
    let newUser: TUserDoc
    try {
      //create a new user
      const newUser = await this.usersService.create(signUpDto)

      //asign a token- pass
      const accessToken = await this.signedToken(newUser.id)

      //set up default role for the signed up user to be guest
      await this.asignedDefaultRole(newUser)

      // await this.asignedDefaultRole(newUser)

      //@Todo send email to user

      return {
        accessToken,
        data: newUser,
      }
    } catch (error) {
      //roll back the registration of the user

      if (newUser) {
        await this.usersService.removeHelper(newUser.id)
      }

      //errors to throw(logger)
      this.logger.warn(error.message)
      this.logger.error(error)

      const message = 'Failed to create your account fields, please try again'

      // validation messages
      if (error instanceof NotFoundException) {
        new NotFoundException(message)
      }

      if (error instanceof ForbiddenException) {
        new ForbiddenException(message)
      }

      if (error.code === 11000 || error instanceof ConflictException) {
        const autoMessage =
          this.factoryUtils.autoGenerateDuplicateMessage(error)

        throw new ConflictException(autoMessage || message)
      }

      if (error instanceof Error && error.name === 'ValidationError') {
        throw new BadRequestException(message)
      }

      throw new InternalServerErrorException(message)
    }
  }

  async signIn(signInDto: SignInDto) {
    const message = 'Password of Email is incorrect'
    const { email, password } = signInDto
    try {
      //verify user
      const foundUser = await this.usersService.findOneHelper('custom', {
        email,
      })

      //verify password
      const passwordMatches = await this.hashingService.compare(
        password,
        foundUser.password,
      )

      //allow access
      if (!passwordMatches) {
        throw new ForbiddenException()
      }

      // sign access token
      const accessToken = await this.signedToken(foundUser.id)

      return {
        accessToken,
        data: foundUser,
      }
    } catch (error) {
      this.logger.warn(
        `user with email ${email} could not sign in because of invalid creadetials`,
      )
      this.logger.error(error)

      throw new UnauthorizedException(message)
    }
  }

  async switchAccount(accountOwnerId: string, activeUser: IActiveUser) {
    const memberId = activeUser?.memberId

    this.logger.log(`User Id ${memberId} is switching accounts`)

    try {
      if (memberId) {
        throw new ForbiddenException(
          'Please switch to an account you are a member of',
        )
      }
      //find the access from accessService
      const foundAccess = await this.accessesService.findOneHelper(true, {
        assignedFor: activeUser.memberId,
        accoutOwner: accountOwnerId,
        $and: [{ isEnabled: true }],
      })

      //If there is an access find if the access, generate a new token, client direct into another page to invalidate the former token and assign the new one
      const accessToken = await this.signedToken(accountOwnerId, memberId)
      //assign token with two pay load 1. account owner id 2. member id

      return {
        accessToken,
        data: foundAccess,
      }
    } catch (error) {
      this.logger.warn(
        `User with Id ${memberId} was not able to switch to the account of user with Id ${accountOwnerId}`,
      )
      this.logger.error(error)

      if (
        error instanceof NotFoundException ||
        error instanceof ForbiddenException
      ) {
        throw new UnauthorizedException(
          'You lack enough credentials to swithch to this account',
        )
      }

      throw new InternalServerErrorException(
        'Failed to switch you into this account please try again later',
      )
    }
  }

  /**
   * ---------------------------------------------------------------
   * Helpers
   * -----------------------------------------------------------------
   */

  private async signedToken<P extends Record<string, unknown>>(
    userId: string,
    memberId?: string,
    customPayload?: P,
  ) {
    const payLoad = {
      sub: userId,
      ...(memberId ? { memberId } : {}),
      ...(customPayload ? customPayload : {}),
    }

    const accessToken = await this.jwtService.signAsync(payLoad, {
      secret: this.jwtConfig.secret,
      audience: this.jwtConfig.audience,
      issuer: this.jwtConfig.issuer,
      expiresIn: this.jwtConfig.accessTokenTTL,
    })
  }

  private async asignedDefaultRole(newUser: TUserDoc) {
    const role = await this.rolesService.findOneHelper(this.defaultRole)

    const { id } = role

    const accessDto = {
      assignedTo: newUser.id,
      roleId: id,
      accountOwner: newUser.id,
      baseRole: this.defaultRole,
    }

    this.accessesService.createAccessHelper(accessDto)
  }
}
